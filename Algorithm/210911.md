# 21/09/11 프로그래머스 알고리즘 강의 공부
#### 강의: <a>https://programmers.co.kr/learn/courses/57</a> 
***
## 큐 (Queue)
* 자료를 넣을 수 있는 (선형) 구조
* 넣을 때(enqueue)는 한 쪽 끝에서 밀어 넣어야 하고, 꺼낼 때(dequeue)는 반대 쪽에서 뽑아 꺼내야 하는 구조이다.
* 간단히 말하면 먼저 넣은게 먼저 빠진다. <b>(FIFO: First In First Out)</b>
### 큐의 활용
* 자료를 생성하는 작업과 그 자료를 이용하는 작업이 비동기적으로 (asynchronously) 일어나는 경우
* 자료를 생성하는 작업이 여러 곳에서 일어나는 경우
* 자료를 이용하는 작업이 여러 곳에서 일어나는 경우
* 자료를 생성하는 작업과 이용하는 작업이 여러 곳에서 일어나는 경우
* 자료를 처리하여 새로운 자료를 생성하고, 나중에 그 자료를 또 처리해야 하는 작업의 경우
### 환형 큐 (Circular Queue)
* <b>정해진 갯수</b>의 저장 공간을 빙 돌려가며 사용
* 큐가 가득 차면 더 이상 원소를 넣을 수 없음 (큐 길이 기억)
* 넣을 부분 rear, 첫 부분 front 위치 설정 (한 번 꺼낼수록 front 이동됨)
***
### 배열(list)을 이용한 큐 구현
```python
class ArrayQueue():
  def __init__(self):
    self.data = []
  
  def size(self):
    return len(self.data)
  
  def isEmpty(self):
    return self.size() == 0
  
  def enqueue(self, item):
    self.data.append(item)
  
  def dequeue(self):
    return self.data.pop(0)
  
  def peek(self):
    return self.data[0]

# 환형 큐 구현
class CircularQueue():
  def __init__(self, n):
    self.maxCount = n
    self.data = [None] * n
    self.count = 0
    self.front -= 1
    self.rear = -1
  
  def size(self):
    return self.count
    
  def isEmpty(self):
    return self.count == 0
  
  def isFull(self):
    return self.count == self.maxCount
    
  def enqueue(self, x):
    if self.isFull():
      raise IndexError('Queue Full')
    self.rear = ###something###
    self.data[self.rear] = x
    self.count += 1
  
  def dequeue(self):
    if self.isEmpty():
      raise IndexError('Queue Empty')
    self.front = (self.front + 1) % self.maxCount
    x = self.data[self.front]
    self.count -= 1
    return x
  
  def peek(self):
    if self.isEmpty():
      raise IndexError('Queue Empty')
    return self.data[(self.front + 1) % self.maxCount]
```
#### 🚨배열 구현 시의 문제점
* size(), isEmpty(), enqueue(), peek() 함수는 모두 시간복잡도가 O(1)로 금방 끝나지만, dequeue() 함수는 시간복잡도가 <b>O(n)</b>이다.  
* 그 이유는, <b>첫 번째 원소를 꺼냈을 때 나머지 배열들을 다시 한칸씩 이동시켜야 하기 때문</b>이다.
* 때문에 이를 보완하고자 연결 리스트로 구현하기도 한다.
