# 21/09/06 í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ì•Œê³ ë¦¬ì¦˜ ê°•ì˜ ê³µë¶€
#### ê°•ì˜: <a>https://programmers.co.kr/learn/courses/57</a> 
***
## ì—°ê²° ë¦¬ìŠ¤íŠ¸ (Linked list)
### ì¶”ìƒì  ìë£Œêµ¬ì¡° (Abstract Data Structures)
ìë£Œêµ¬ì¡°ì˜ ë‚´ë¶€ êµ¬í˜„ì€ ìˆ¨ê²¨ë‘ê³  ë°–ì—ì„œ ë³´ì´ëŠ” ê²ƒë“¤ (ë°ì´í„°, ì—°ì‚°)ë§Œ ì œê³µí•˜ëŠ” ê²ƒ
### ê¸°ë³¸ì  ì—°ê²° ë¦¬ìŠ¤íŠ¸
* ì•ì— ìˆëŠ” ê²ƒì´ ë’¤ì— ìˆëŠ” ê²ƒì„ ê°€ë¦¬í‚¤ëŠ” í˜•íƒœ (ë…¸ë“œ)
* í•œ ë…¸ë“œì—ëŠ” ë°ì´í„°ì™€ ë‹¤ìŒ ë…¸ë“œì˜ ë§í¬ê°€ í•¨ê»˜ ì €ì¥ë˜ì–´ ìˆë‹¤.
* ì²˜ìŒ ë…¸ë“œ(Head), ë§ˆì§€ë§‰ ë…¸ë“œ(Tail), ë…¸ë“œ ê°¯ìˆ˜(count)ë¥¼ ì•Œì•„ë‘ê¸°
```python
# ë…¸ë“œ í´ë˜ìŠ¤
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None    
# ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ í´ë˜ìŠ¤
class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.nodeCount = 0 
    # ë…¸ë“œ ì–»ì–´ë‚´ê¸°
    def getAt(self, pos):
        if pos < 1 or pos > self.nodeCount:
            return None
        i = 1
        curr = self.head
        while i < pos:
            curr = curr.next
            i += 1
        return curr
    # ë¦¬ìŠ¤íŠ¸ ë…¸ë“œ ì°¸ì¡°
    def traverse(self):
        lists = []
        curr = self.head
        if self.nodeCount == 0:
            return lists
        while curr is not None:
            lists.append(curr.data)
            curr = curr.next
        return lists
    # ë…¸ë“œ ì‚½ì…
    def insertAt(self, pos, newNode):
        if pos < 1 or pos > self.nodeCount + 1:
            return False
        if pos == 1:
            if pos == self.nodeCount + 1:
                self.head = newNode
                self.tail = newNode
            else:
                newNode.next = self.head
                self.head = newNode
        else:
            if pos == self.nodeCount + 1:
                prev = self.tail
                prev.next = newNode
                self.tail = newNode
            else:
                prev = self.getAt(pos - 1)
                newNode.next = prev.next
                prev.next = newNode
        self.nodeCount += 1
        return True
    # ë…¸ë“œ ì‚­ì œ 
    def popAt(self, pos):
        if pos < 1 or pos > self.nodeCount:
            return False
        curr = self.getAt(pos)
        if pos == 1:
            self.head = curr.next
            if pos == self.nodeCount:
                self.tail = curr.next
        else:
            prev = self.getAt(pos - 1) 
            if pos == self.nodeCount:
                self.tail = prev
                prev.next = None
            else:
                prev.next = curr.next
        self.nodeCount -= 1
        return True
```
***
### ì—…ê·¸ë ˆì´ë“œ: prevë¥¼ ì–»ì–´ ë°”ë¡œ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ì‚½ì…, ì‚­ì œí•˜ê¸°
```python
# insertAfter
def insertAfter(self, prev, newNode):
    newNode.next = prev.next
    if prev.next is None: # ì´ì „ ë…¸ë“œì˜ ë‹¤ìŒ ë…¸ë“œê°€ Noneì´ë©´ ë§¨ ë’¤ì— ìƒˆë¡­ê²Œ ì¶”ê°€í•œë‹¤ëŠ” ì˜ë¯¸. tailì— ëª…ì‹œí•´ì¤„ í•„ìš” ìˆë‹¤.
        self.tail = newNode
    prev.next = newNode
    self.nodeCount += 1
    return True
# ë‹¬ë¼ì§„ insertAt í•¨ìˆ˜
def insertAt(self, pos, newNode):
    if pos < 1 or pos > self.nodeCount + 1:
        return False
    if pos != 1 and pos == self.nodeCount + 1:
        prev = self.tail    # posê°€ ë§ˆì§€ë§‰ ë…¸ë“œì¼ ë•ŒëŠ” ì´ì „ì— tailì´ì—ˆë˜ ê²Œ prevê°€ ëœë‹¤.
    else:
        prev = self.getAt(pos - 1)  # posê°€ 1ë²ˆì¼ ë•ŒëŠ” dummy nodeë¥¼ get í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ìœ„ì˜ ì¡°ê±´ì—ì„œ pos != 1ì¸ ê²ƒì´ë‹¤.
    return self.insertAfter(prev, newNode)
# popAfter
def popAfter(self, prev):
    curr = prev.next    # prevë¥¼ ì´ìš©í•´ í˜„ì¬ ë…¸ë“œë¥¼ ì„¤ì •í•œë‹¤.
    if prev.next is None: # í˜„ì¬ ë…¸ë“œê°€ Noneì´ë©´ ì‚­ì œí•˜ë ¤ëŠ” ë…¸ë“œê°€ ì—†ëŠ”ê±°
        return None
    if curr.next is None:   # í˜„ì¬ì˜ ë‹¤ìŒ ë…¸ë“œê°€ Noneì¸ ê²½ìš°ëŠ” ë§ˆì§€ë§‰ì¸ ê²½ìš°ë°–ì— ì—†ìŒ
        # 1 < pos = nodeCount, 1 = pos = nodeCount (tail ì¡°ì •í•´ì•¼ í•¨)
        self.tail = prev
        prev.next = None
    else:   # ê·¸ ì´ì™¸ì˜ ê²½ìš° (1 <= pos < nodeCount: head, tail ë³€í™” ì—†ìŒ)    
        prev.next = curr.next
    self.nodeCount -= 1
    return curr.data
# ë‹¬ë¼ì§„ popAt í•¨ìˆ˜
def popAt(self, pos):
    if pos < 1 or pos > self.nodeCount:
        raise IndexError
    prev = self.getAt(pos - 1)  # self.headì— ì´ë¯¸ dummy ë…¸ë“œê°€ ìˆìœ¼ë¯€ë¡œ headëŠ” ê³ ì³ì§ˆ ì¼ì´ ì—†ë‹¤.
    return self.popAfter(prev)
```
***
## ğŸ¤”ê¶ê¸ˆì¦
### 1. ì—°ê²° ë¦¬ìŠ¤íŠ¸ ì›ì†Œ ì‚­ì œ ë” ìì„¸íˆ ì•Œì•„ë³´ê¸°
traverse í•¨ìˆ˜ë¥¼ ë³´ë©´, currì€ self.headë¶€í„° ì‹œì‘í•˜ê³  ìˆë‹¤.  
<b>ì¦‰, ìˆœíšŒë¥¼ í•  ë•Œ self.headì˜ ì´ì „ ë…¸ë“œë“¤ì— ëŒ€í•´ì„œëŠ” ì ‘ê·¼í•  ë°©ë²•ì´ ì—†ë‹¤.</b>  
ê·¸ë ‡ê¸°ì— íŒŒì´ì¬ì—ì„œëŠ” <b>ê°€ë¹„ì§€ ì»¬ë ‰íŒ… (Garbage Collecting)</b>ì„ í•´ì„œ self.headì˜ ì´ì „ ë…¸ë“œë“¤ì— ëŒ€í•´ì„  í•„ìš” ì—†ëŠ” ë…¸ë“œë¡œ ì²˜ë¦¬ë¥¼ í•´ ë²„ë¦°ë‹¤.  
ë”°ë¼ì„œ popAt í•¨ìˆ˜ì—ì„œ, 1 = pos <= self.nodeCountì¼ ë•Œ, self.headë¥¼ curr.nextë¡œ í•´ ë‘ê¸°ë§Œ í•˜ë©´, curr.next = Noneì„ ì…ë ¥í•  í•„ìš”ê°€ ì—†ë‹¤.  
1 = pos <= self.nodeCountì¸ ìƒí™©ì—ì„œëŠ”, self.head = curr.nextë¡œ í•´ë‘ê³ , posê°€ self.nodeCountì™€ ê°™ì„ ë•Œë§Œ (ì¦‰ nodeCountê°€ 1ê°œì¼ ë•Œ) self.tailë„ Noneìœ¼ë¡œ í•´ ë‘ë©´ ëœë‹¤.  
